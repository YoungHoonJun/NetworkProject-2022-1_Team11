앞서 말한 rtp를 이용하여 저희 팀은 reliable streaming을 구현해 보았습니다. 실은 video 라기보단 사진을 이용한 건데...

일단, 사진이 있습니다. 오른쪽에 스윙스랑 삼장이 보이는데 얘네 두장으로 진행했습니다. 총 12장이 있고, 각각 6개씩 고화질부터 저화질의 사진이 input으로 받아집니다.
그리고 frameFile 이란 이름으로 두 사진들의 이름이 100번 input에 들어오는데, - 예를 들어 스윙스 삼장 스윙스 스윙스 삼장 - frameRate가 25면 그게 4초짜리 영상이 되는 겁니다.
25frame에 1초 영상으로 취급하는 겁니다.
마치 옛날에 디즈니 애니메이션처럼 말이죠.
즉 이제 이 텍스트 파일은 (클릭) 1초짜리 영상이에요!
저희 model은 이 영상을 서버에서 클라로 전달하는 것을 목적으로 합니다.
(클릭)

클라는 frame을 쌓아 놓다가 25개 이상이 되면 1초 분량의 사진 25개를 -원래는 화면에 보여줘야 하겠지만- 파일로 저장합니다.

(클릭)
이때 클라이언트가 판단을 합니다. 적절한 양의 frame이 오면 딱 좋겠죠. 그치만 아닐 수도 있습니다. 여기서 영상이 buffering이 많이 걸리면, 즉 frameRate만큼의 이미지를 1초에 못 받아서 출력을 못하면, 좀 더 저화질로 보면은 더 끊김 없이 볼 수 있으니까 용량이 작은 걸로 달라고 서버에 말을 해줍니다.
반면 막 버퍼에 5초 이상의 영상이 쌓여 있으면 솔직히 좀 더 고화질로 보아도 괜찮다는 이야기니까 큰 파일, 즉 고화질의 영상을 달라고 하고요.


보통은 이미지 크기가 packet 크기보다 큽니다. 그렇기 때문에 (클릭) 이렇게! 패킷 여러개에 나눠 보내야 하는데, 그때 rtp헤더를  써서 reliable하게 구현합니다. (클릭) frame 각각에 seq번호를 부여합니다. 그리고 그 정보를  rtp 헤더에 그 정보를 써 놓는 거예요. 예를 들어 이 패킷은 1 - 8 seq 인 frame의 2번째 seq 인 패킷이다. (실은 8 하나밖에 안 써 놓습니다) 이런 느낌으로요. (좀 있다가 클릭) 그러면 클라는 8 값을 저장해 놓고 후에 8이나 그보다 큰 패킷이 오면. 오.. 내가 frame을 구성할 1-8의 패킷이 전부 있나? 를 검사하는 거죠. 근데 예를 들어 5가 없어요? 그럼 서버한테 달라고 합니다. 그러면 완전성을 보장할 수 있습니다.

다만 여기서 '패킷이 올때', frame 구성을 진행하기 때문에 막판에 패킷이 전부 다 우수수 떨어지면 frame 구성을 안해서, 초반 부 영상만 남는 경우도 생기는데, 어차피 streaming이라 저희 예제에서는 그렇게 큰 문제가 생기지 않을 것 같습니다. 끊임없이 영상이 오니까요. 원래..

추가적으로 서버는 만약에, 갑자기 클라가 죽으면 시간을 셌다가 그 클라에게의 전송을 멈추는 기능도 가지고 있어요. RTP랑 크게 관련 없는 부가적인 기능입니다. 구현해놓고 말 안하긴 뭐해서 써놨습니다.